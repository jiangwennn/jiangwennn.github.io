{"meta":{"title":"Jiangwennn的学习笔记","subtitle":"","description":"不积跬步无以至千里","author":"Jiangwennn","url":"http://jiangwennn.github.io","root":"/"},"pages":[{"title":"","date":"2022-06-26T12:54:57.431Z","updated":"2022-06-26T12:54:57.431Z","comments":true,"path":"404.html","permalink":"http://jiangwennn.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2022-06-26T12:54:04.576Z","updated":"2022-06-26T12:54:04.576Z","comments":true,"path":"categories/index.html","permalink":"http://jiangwennn.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-06-26T12:54:24.966Z","updated":"2022-06-26T12:54:24.966Z","comments":true,"path":"tags/index.html","permalink":"http://jiangwennn.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2022-06-15T12:03:27.000Z","updated":"2022-06-15T12:03:27.603Z","comments":true,"path":"about/index.html","permalink":"http://jiangwennn.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"使用Windows包管理器Scoop安装SwitchHosts","slug":"windows-scoop-switchhosts","date":"2021-08-29T03:03:01.000Z","updated":"2022-06-26T12:39:04.653Z","comments":true,"path":"/post/windows-scoop-switchhosts.html","link":"","permalink":"http://jiangwennn.github.io/post/windows-scoop-switchhosts.html","excerpt":"","text":"为当前Windows账户启用PowerShellSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser 配置安装目录如果需要配置全局安装目录，需要PowerShell在管理员模式下运行可以使用 win + q搜索打开PowerShell管理员模式，也可以执行以下命令Start-Process PowerShell -verb runAs 用户安装的程序和scoop本身位于C:\\Users\\scoop。全局安装的程序（–global）位于C:\\ProgramData\\scoop。可以通过环境变量更改这些设置。具体步骤如下： # 将Scoop安装到自定义目录(命令行方式) $env:SCOOP=&#39;D:\\Scoop&#39; [Environment]::SetEnvironmentVariable(&#39;SCOOP&#39;, $env:SCOOP, &#39;User&#39;) # 将Scoop配置为将全局程序安装到自定义目录 SCOOP_GLOBAL(命令行方式)，这一步可省略 $env:SCOOP_GLOBAL=&#39;D:\\GlobalScoopApps&#39; [Environment]::SetEnvironmentVariable(&#39;SCOOP_GLOBAL&#39;, $env:SCOOP_GLOBAL, &#39;Machine&#39;) 安装Scoop执行以下命令中的一个即可安装 Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&#39;https://get.scoop.sh&#39;) # 或 iwr -useb get.scoop.sh | iex 安装完成后执行scoop help验证是否安装成功 PS C:\\Windows\\system32&gt; scoop help Usage: scoop &lt;command&gt; [&lt;args&gt;] Some useful commands are: alias Manage scoop aliases bucket Manage Scoop buckets cache Show or clear the download cache checkup Check for potential problems cleanup Cleanup apps by removing old versions config Get or set configuration values create Create a custom app manifest depends List dependencies for an app export Exports (an importable) list of installed apps help Show help for a command hold Hold an app to disable updates home Opens the app homepage info Display information about an app install Install apps list List installed apps prefix Returns the path to the specified app reset Reset an app to resolve conflicts search Search available apps status Show status and check for new app versions unhold Unhold an app to enable updates uninstall Uninstall an app update Update apps, or Scoop itself virustotal Look for app&#39;s hash on virustotal.com which Locate a shim/executable (similar to &#39;which&#39; on Linux) Type &#39;scoop help &lt;command&gt;&#39; to get help for a specific command. 配置代理加速由于众所周知的原因，使用scoop安装网速会比较慢，这里配置一下代理加速，也就是本地的代理地址了scoop config proxy 127.0.0.1:7890这一步也可以通过修改scoop的配置文件~/.config/scoop/config.json实现 软件安装 添加bucket软件源scoop bucket add extras 安装aria2aria2是一款下载工具，安装以后可以提高scoop下载的速度scoop install aria2 安装switchhostsswitchhosts可以很方便的管理和切换hostsscoop install switchhosts 安装figletfiglet可以将你输入的字符打印在终端上scoop install figletPS C:\\Windows\\system32&gt; figlet I love you ___ _ |_ _| | | _____ _____ _ _ ___ _ _ | | | |/ _ \\ \\ / / _ \\ | | | |/ _ \\| | | | | | | | (_) \\ V / __/ | |_| | (_) | |_| | |___| |_|\\___/ \\_/ \\___| \\__, |\\___/ \\__,_| |___/ 其他Scoop 有许多优秀的Bucket，你可以通过运行scoop bucket known来获取官方支持的bucket: bucket源推荐： scoop bucket add main # 默认 scoop bucket add extras # 推荐 scoop bucket add versions scoop bucket add nightlies scoop bucket add nirsoft scoop bucket add php scoop bucket add nerd-fonts scoop bucket add nonportable scoop bucket add java scoop bucket add games scoop bucket add jetbrains # 推荐 国内常用软件：微信、QQ、钉钉…… scoop bucket add dorado https://github.com/h404bi/dorado 小新Bucket：FSCapture、Shadowsocksrr、UninstallTool、Notepad3、Wechat…… scoop bucket add dajiu https://github.com/dajiiu/dajiu-scoop 其他： scoop bucket add dodorz https://github.com/dodorz/scoop-bucket","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://jiangwennn.github.io/tags/Windows/"},{"name":"Scoop","slug":"Scoop","permalink":"http://jiangwennn.github.io/tags/Scoop/"}],"author":"Jiangwennn"},{"title":"MySQL Explain命令用法","slug":"mysql-explain","date":"2019-05-22T16:23:52.000Z","updated":"2022-06-26T12:50:40.204Z","comments":true,"path":"/post/mysql-explain.html","link":"","permalink":"http://jiangwennn.github.io/post/mysql-explain.html","excerpt":"","text":"一、介绍explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。 使用方法：在select语句前加上explain就可以了： mysql&gt; explain select user,host from user\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: user partitions: NULL type: index possible_keys: NULL key: PRIMARY key_len: 276 ref: NULL rows: 5 filtered: 100.00 Extra: Using index 1 row in set, 1 warning (0.00 sec) 二、准备工作 为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据: CREATE TABLE `user_info` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT, `name` VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, `age` INT(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `name_index` (`name`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8 INSERT INTO user_info (name, age) VALUES (&#39;xys&#39;, 20); INSERT INTO user_info (name, age) VALUES (&#39;a&#39;, 21); INSERT INTO user_info (name, age) VALUES (&#39;b&#39;, 23); INSERT INTO user_info (name, age) VALUES (&#39;c&#39;, 50); INSERT INTO user_info (name, age) VALUES (&#39;d&#39;, 15); INSERT INTO user_info (name, age) VALUES (&#39;e&#39;, 20); INSERT INTO user_info (name, age) VALUES (&#39;f&#39;, 21); INSERT INTO user_info (name, age) VALUES (&#39;g&#39;, 23); INSERT INTO user_info (name, age) VALUES (&#39;h&#39;, 50); INSERT INTO user_info (name, age) VALUES (&#39;i&#39;, 15); CREATE TABLE `order_info` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT, `user_id` BIGINT(20) DEFAULT NULL, `product_name` VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, `productor` VARCHAR(30) DEFAULT NULL, PRIMARY KEY (`id`), KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8 INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &#39;p1&#39;, &#39;WHH&#39;); INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &#39;p2&#39;, &#39;WL&#39;); INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &#39;p1&#39;, &#39;DX&#39;); INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &#39;p1&#39;, &#39;WHH&#39;); INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &#39;p5&#39;, &#39;WL&#39;); INSERT INTO order_info (user_id, product_name, productor) VALUES (3, &#39;p3&#39;, &#39;MA&#39;); INSERT INTO order_info (user_id, product_name, productor) VALUES (4, &#39;p1&#39;, &#39;WHH&#39;); INSERT INTO order_info (user_id, product_name, productor) VALUES (6, &#39;p1&#39;, &#39;WHH&#39;); INSERT INTO order_info (user_id, product_name, productor) VALUES (9, &#39;p8&#39;, &#39;TE&#39;); 三、explain命令输出解析 执行explain后，mysql打印出了许多信息： mysql&gt; explain select * from user_info where id = 2\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: const possible_keys: PRIMARY key: PRIMARY key_len: 8 ref: const rows: 1 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec) 各列含义如下： id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符. select_type: SELECT 查询的类型. table: 查询的是哪个表 partitions: 匹配的分区 type: join 类型 possible_keys: 此次查询中可能选用的索引 key: 此次查询中确切使用到的索引. ref: 哪个字段或常数与 key 一起被使用 rows: 显示此查询一共扫描了多少行. 这个是一个估计值. filtered: 表示此查询条件所过滤的数据的百分比 extra: 额外的信息 1. select_typeselect_type 表示了查询的类型, 它的常用取值有: SIMPLE, 表示此查询不包含 UNION 查询或子查询 PRIMARY, 表示此查询是最外层的查询 UNION, 表示此查询是 UNION 的第二或随后的查询 DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询 UNION RESULT, UNION 的结果 SUBQUERY, 子查询中的第一个 SELECT DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果. 2. table&ensp;表示查询涉及的表或衍生表 3. typetype 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等. type常用类型 system: 表中只有一条数据. 这个类型是特殊的 const 类型. const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可。例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的. mysql&gt; explain select * from user_info where id = 2\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: const possible_keys: PRIMARY key: PRIMARY key_len: 8 ref: const rows: 1 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec) eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如：` mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: order_info partitions: NULL type: index possible_keys: user_product_detail_index key: user_product_detail_index key_len: 314 ref: NULL rows: 9 filtered: 100.00 Extra: Using where; Using index *************************** 2. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: eq_ref possible_keys: PRIMARY key: PRIMARY key_len: 8 ref: test.order_info.user_id rows: 1 filtered: 100.00 Extra: NULL 2 rows in set, 1 warning (0.00 sec) ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. mysql&gt; EXPLAIN SELECT * FROM -&gt; user_info, order_info -&gt; WHERE user_info.id = order_info.user_id -&gt; AND order_info.user_id = 5\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: const possible_keys: PRIMARY key: PRIMARY key_len: 8 ref: const rows: 1 filtered: 100.00 Extra: NULL *************************** 2. row *************************** id: 1 select_type: SIMPLE table: order_info partitions: NULL type: ref possible_keys: user_product_detail_index key: user_product_detail_index key_len: 9 ref: const rows: 1 filtered: 100.00 Extra: Using index 2 rows in set, 1 warning (0.01 sec) range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个,例如下面的例子就是一个范围查询: mysql&gt; EXPLAIN SELECT * -&gt; FROM user_info -&gt; WHERE id BETWEEN 2 AND 8 \\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: range possible_keys: PRIMARY key: PRIMARY key_len: 8 ref: NULL rows: 7 filtered: 100.00 Extra: Using where 1 row in set, 1 warning (0.00 sec) index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index例如： mysql&gt; EXPLAIN SELECT name FROM user_info \\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: index possible_keys: NULL key: name_index key_len: 152 ref: NULL rows: 10 filtered: 100.00 Extra: Using index 1 row in set, 1 warning (0.00 sec) 上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index. ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免. 下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的. mysql&gt; EXPLAIN SELECT age FROM user_info WHERE age = 20 \\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 10 filtered: 10.00 Extra: Using where 1 row in set, 1 warning (0.00 sec) type 类型的性能比较 通常来说, 不同的 type 类型的性能关系如下: ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快. 后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了. 4. possible_keyspossible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到.MySQL 在查询时具体使用了哪些索引, 由 key 字段决定. 5. key此字段是 MySQL 在当前查询时所真正使用到的索引. 6. key_len表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.key_len 的计算规则如下: 字符串 char(n): n 字节长度 varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节. 数值类型: TINYINT: 1字节 SMALLINT: 2字节 MEDIUMINT: 3字节 INT: 4字节 BIGINT: 8字节 时间类型 DATE: 3字节 TIMESTAMP: 4字节 DATETIME: 8字节 字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性. 举例： mysql&gt; EXPLAIN SELECT * FROM order_info -&gt; WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39; \\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: order_info partitions: NULL type: range possible_keys: user_product_detail_index key: user_product_detail_index key_len: 9 ref: NULL rows: 5 filtered: 11.11 Extra: Using where; Using index 1 row in set, 1 warning (0.00 sec) 上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引: KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`) 不过此查询语句 WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39; 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT &#39;0&#39;, 则 key_length 应该是8. 上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高. 看下一个例子： mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = &#39;p1&#39; \\G; *************************** 1. row *************************** id: 1 select_type: SIMPLE table: order_info partitions: NULL type: ref possible_keys: user_product_detail_index key: user_product_detail_index key_len: 161 ref: const,const rows: 2 filtered: 100.00 Extra: Using index 1 row in set, 1 warning (0.00 sec) 这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = &#39;p1&#39; 中, 仅仅使用到了联合索引中的前两个字段, 因此keyLen(user_id)+ keyLen(product_name) = 9 + 50 * 3 + 2 = 161 7. rowsrows 也是一个重要的字段.MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好. 8. ExtraEXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容: Using filesort当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果；一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大. 例如下面的例子： mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: order_info partitions: NULL type: index possible_keys: NULL key: user_product_detail_index key_len: 253 ref: NULL rows: 9 filtered: 100.00 Extra: Using index; Using filesort 1 row in set, 1 warning (0.00 sec) 我们的索引是 KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`) 但是上面的查询中根据product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如: mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: order_info partitions: NULL type: index possible_keys: NULL key: user_product_detail_index key_len: 253 ref: NULL rows: 9 filtered: 100.00 Extra: Using index 1 row in set, 1 warning (0.00 sec) Using index“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错 Using temporary查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://jiangwennn.github.io/tags/MySQL/"}],"author":"Jiangwennn"},{"title":"MySQL数据类型与约束条件","slug":"mysql-data-type","date":"2019-05-14T14:50:49.000Z","updated":"2022-06-26T13:00:21.051Z","comments":true,"path":"/post/mysql-data-type.html","link":"","permalink":"http://jiangwennn.github.io/post/mysql-data-type.html","excerpt":"","text":"一、MySQL的数据类型主要包括以下五大类： 整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT 浮点数类型：FLOAT、DOUBLE、DECIMAL 字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB 日期类型：Date、DateTime、TimeStamp、Time、Year 其他数据类型：BINARY、VARBINARY、ENUM、SET、 Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等 1. 整数型 类型 字节 范围（有符号） 范围（无符号） TINYINT(m) 1 (-128，127) (0，255) SMALLINT(m) 2 (-32768，32767) (0，65535) MEDIUMINT(m) 3 (-8388608，8388607) (0，16777215) INT(m) 4 (-2147483 648，2147483647) (0，4294967295) BIGINT(m) 8 (-9223372036854775808，9223372036854775807) (0，18446744073709551615) 对于整型类型，后面括号里的m指的是显示宽度，显示宽度与所能存储的数据范围无关，目前已知的是当设置了ZEROFILL（填充0）约束条件时，填充 0的 个数由m决定， 例如：设置id int(5) ZEROFILL ，属性id会填充成如下形式 +-----------+-----------+ | id | name | +-----------+-----------+ | 00001 | Jane | +-----------+-----------+ | 00002 | Mike | +-----------+-----------+ 2. 浮点数和定点数 类型 大小 用途 FLOAT 4字节 单精度浮点数值 DOUBLE 8字节 双精度浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 小数值 设一个字段定义为float(6,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。整数部分最大是3位，如果插入数12.123456，存储的是12.1234，如果插入12.12，存储的是12.1200. 浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。decimal(m,d) 参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位。 为了能够引起大家的重视，请看下面的例子： mysql&gt; CREATE TABLE test (c1 float(10,2),c2 decimal(10,2)); Query OK, 0 rows affected (0.29 sec) mysql&gt; insert into test values(131072.32,131072.32); Query OK, 1 row affected (0.07 sec) mysql&gt; select * from test; +-----------+-----------+ | c1 | c2 | +-----------+-----------+ | 131072.31 | 131072.32 | +-----------+-----------+ 1 row in set (0.00 sec) 从上面的例子中我们看到c1列的值由131072.32变成了131072.31，这就是浮点数的不精确性造成的。 在mysql中float、double（或real）是浮点数，decimal（或numberic）是定点数。 浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的数据范围；它的缺点是会引起精度问题。在今后关于浮点数和定点数的应用中，大家要记住以下几点： 浮点数存在误差问题； 对货币等对精度敏感的数据，应该用定点数表示或存储； 编程中，如果用到浮点数，要特别注意误差问题，并尽量避免做浮点数比较； 要注意浮点数中一些特殊值的处理。 3. 日期时间 类型 字节 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 datetime 5.6版本后只占 5 个字节 若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。timestamp和datetime从MySQL5.6开始都支持自动更新为当前时间 4. 字符串类型 类型 大小 用途 CHAR 0-255字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 1.char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以 char 类型存储的字符串末尾不能有空格，varchar 不限于此。 2.char(n) 固定长度，char(4) 不管是存入几个字符，都将占用 4 个字节，varchar 是存入的实际字符数 +1 个字节（n&lt;=255）或2个字节(n&gt;255)，所以 varchar(4),存入 3 个字符将占用 4 个字节。 3.char 类型的字符串检索速度要比 varchar 类型的快。 **varchar 和 text**： 1.varchar 可指定 n，text 不能指定，内部存储 varchar 是存入的实际字符数 +1 个字节（n&lt;=255）或 2 个字节(n&gt;255)，text 是实际字符数 +2 个字节。 2.text 类型不能有默认值。 3.varchar 可直接创建索引，text 创建索引要指定前多少个字符。varchar 查询速度快于 text, 在都创建索引的情况下，text 的索引似乎不起作用。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 varchar(100)中的100代表的是字符的概念，在不同字符集下所占空间是不一样的，例如在UTF8字符集下，存储空间为100*3 +1 = 301个字节 blob和text值会引起一些性能问题，特别是在执行了大量删除操作时，会在数据表中留下很大的“空洞”，即表碎片；这对后续的插入操作性能影响很大 问题：如何提高text或blob类型字段的查询性能？ 进行表碎片整理 对text或blob字段进行hash并存储hash值，提高查询性能 前缀索引 避免对text或blob等大字段直接检索；建议不要将这两个字段和业务表放在一起 二、MySQL属性约束条件 MySQL关键字 含义 NULL 数据列可包含NULL值 NOT NULL 数据列不允许包含NULL值 DEFAULT 默认值 PRIMARY KEY 主键 AUTO_INCREMENT 自动递增，适用于整数类型 UNSIGNED 无符号 ZEROFILL 填充零 CHARACTER SET name 指定一个字符集","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://jiangwennn.github.io/tags/MySQL/"}],"author":"Jiangwennn"},{"title":"phpstorm + xdebug断点调试","slug":"phpstorm-xdebug","date":"2019-04-21T03:56:46.000Z","updated":"2022-06-24T10:17:52.730Z","comments":true,"path":"/post/phpstorm-xdebug.html","link":"","permalink":"http://jiangwennn.github.io/post/phpstorm-xdebug.html","excerpt":"","text":"一、安装Xdebug在Xdebug官网下载页可以下载xdebug，可以根据自己的PHP版本下载对应的xdebug版本，需要注意的有三个关键点： PHP版本号 5.x 还是 7.x 32位还是64位 TS（线程安全）还是NTS（非线程安全） 如果不太清楚自己的PHP版本,可以点击下图所示红框内的链接，分析phpinfo打印的信息，自动提供对应的下载版本 浏览器打开phpinfo信息，ctrl + a全选 ，ctrl + c 复制 ctrl + v粘贴到分析页面的输入框内，点击分析按钮 按照分析结果给出的指示，一步一步完成就好了。这里分析后的路径都是正确的，对应了你本机的路径。 重启服务器后再次打开phpinfo，验证安装是否成功，ctrl + F 搜索 xdebug关键字，显示如下版本信息即安装成功 二、配置xdebug本文开启的配置如下 [XDebug] xdebug.profiler_output_dir=&quot;D:\\phpStudy\\tmp\\xdebug&quot; xdebug.trace_output_dir=&quot;D:\\phpStudy\\tmp\\xdebug&quot; zend_extension=&quot;D:\\phpStudy\\php\\php-7.1.27\\ext\\php_xdebug.dll&quot; xdebug.remote_enable = 1 xdebug.remote_autostart = 1 xdebug.remote_host = localhost xdebug.remote_mode = req xdebug.remote_handler = dbgp xdebug.remote_port = 9000 xdebug.idekey = PHPSTORM ####【xdebug配置说明】 开启Xdebug方式的错误提示：只要启用了xdebug扩展那么该功能是默认开启的，将以xdebug的风格进行错误显示，如果想以原php的风格显示可以在配置文件中设置：xdebug.default_enable=0，注意该设置项并不是指关闭xdebug的所有功能 配置大变量的显示：在有些程序中变量会很大，比如著名内容管理系统drupal8中的节点渲染数组，如果直接print_r那么可以将内存8G的I5计算机卡死，所以Xdebug提供了配置大变量打印配置以避免这种情况，配置以下配置项：xdebug.var_display_max_children整数，默认128，显示的数组子元素或对象属性的最大数量，不限制则设定为-1，远程调试时不受影响xdebug.var_display_max_data整数，默认512，显示字符串的最大长度，不限设置为-1，不影响远程调试xdebug.var_display_max_depth整数，默认3，显示数组或对象属性时的最大嵌套深度，最大1023，可以用-1指代这个最大数 最大递归保护：设定以下配置项：xdebug.max_nesting_level整数，默认为：256，不限设置为-1，无限递归的保护机制，当递归调用达到该设定时程序被中断，注意此时不会出现任何错误提示，而是直接退出程序 函数调用追踪：包括对象方法调用，该功能默认是关闭的，开启后将输出调用数据到一个文件，查看文件即可，配置如下（这里值设定为我们最常用的情况以便复制使用，更多见下文的配置说明）：xdebug.auto_trace=1;开启追踪，默认是关闭的xdebug.trace_output_dir=&quot;C:\\root\\xdebug\\trace&quot;;调用追踪数据输出目录xdebug.trace_output_name=&quot;yunke.%s.%u&quot;;追踪文件的文件名xdebug.collect_params=4;收集函数参数的形式xdebug.collect_return=1;是否收集函数返回值xdebug.show_mem_delta=1;显示内存详情xdebug.trace_format=0;追踪文件的格式 以上设置将为所有请求产生分析文件，调用追踪分析还可以采用变量触发的方式（可通过浏览器扩展自动完成，这也是推荐方法，见下），也就是在GET/POST 或COOKIE中设置变量名XDEBUG_TRACE，它的值是和以下设置项匹配的密钥，配置如下：xdebug.auto_trace=0;开启变量触发跟踪时自动跟踪需要关闭xdebug.trace_enable_trigger=1xdebug.trace_enable_trigger_value=&quot;yunke&quot;;这就是上述XDEBUG_TRACE变量的值如访问网址：http://www.test.com/index.php?XDEBUG_TRACE=yunke，即可触发追踪文件的产生这里”yunke”是一个密钥值，只有和配置文件匹配才能产生分析文件，默认为空字符 代码覆盖分析：该功能可以让我们知道代码执行中哪些行被执行到了，通常用于单元测试，配置如下：xdebug.coverage_enable=1;代码覆盖分析开启 代码覆盖分析是通过在php代码中调用函数来进行的，过程如下，那将得到一个数组结果： xdebug_start_code_coverage();//开启覆写 …//被分析的一些代码 var_dump(xdebug_get_code_coverage());//得到一个分析结果数组 垃圾回收分析：该功能默认是关闭的，开启后将输出垃圾回收分析数据到一个文件，查看文件即可，配置如下（这里值设定为我们最常用的情况以便复制使用，更多见下文的配置说明）：xdebug.gc_stats_enable=1;开启垃圾回收分析xdebug.gc_stats_output_dir=&quot;C:\\root\\xdebug\\gc&quot;;数据输出目录，默认是/tmpxdebug.gc_stats_output_name=”gcstats.%s.%u”;输出文件名，默认是: gcstats.%p 程序性能分析：该功能默认是关闭的，开启后将输出性能分析数据到一个文件，该文件是便于机器解析的文本格式，需要专用软件查看，配置如下（这里值设定为我们最常用的情况以便复制使用，更多见下文的配置说明）：xdebug.profiler_enable=1;开启性能分析xdebug.profiler_output_dir=&quot;C:\\root\\xdebug\\profiler&quot;;性能分析文件输出目录xdebug.profiler_output_name=&quot;cachegrind.out.%s.%u&quot;;性能分析输出文件名 以上设置将为所有请求产生分析文件，性能分析还可以采用变量触发的方式（可通过浏览器扩展自动完成，这也是推荐方法，见下），也就是在GET/POST 或COOKIE中设置变量名XDEBUG_PROFILE，它的值是和以下设置项匹配的密钥，配置如下：xdebug.profiler_enable=0;开启变量触发分析时自动分析需要关闭xdebug.profiler_enable_trigger=1xdebug.profiler_enable_trigger_value=&quot;yunke&quot;;这就是上述XDEBUG_PROFILE变量的值即可触发分析文件的产生，如访问网址：http://www.test.com/index.php?XDEBUG_PROFILE=yunke这里”yunke”是一个密钥值，只有和配置文件匹配才能产生分析文件，默认为空字符 在官网介绍了许多种软件来查看输出的分析文件，其中WinCacheGrind在小型程序分析中尚可，大型程序就力不从心了，甚至会出现错误，经云客测试采用QCacheGrind 效果最好，它是KCacheGrind的Windows版本，这里对该软件做一个简单介绍：打开后左边有一个“Flat Profile”面板，里面第一列“Incl.”是执行时间，包括内部调用的子程序的时间；Self列是自身消耗的时间，不包括子函数调用；Called列是该函数被调用的次数；Function是函数名；Location列是文件位置；时间是以微秒为单位1秒=1000000 微秒(μs)，以可以采用百分比的方式 远程调试：我们先看一下远程调试的整个过程，首先由浏览器附带特殊参数打开要调试的脚本，脚本开始运行，此时Xdebug会主动向配置好的调试客户端发起一个连接，并采用DBGp协议和调试客户端交互（调试客户端往往就是我们使用的IDE，如phpstorm，它需要监听调试网络端口），调试客户端通过协议让Xdebug一步一步的执行代码，显示或设置程序中的变量内容，在每一步之间Xdebug将php程序挂起暂停执行，这个“步”又叫断点，调试客户端可以通过设置断点来让程序在该处暂停，对于调试客户端而言这又叫做断点调试，整个过程而言是Xdebug在php引擎里一步一步的执行代码并操作这个过程，她接收调试客户端的指令。要进行远程调试具体操作如下，首先需要以下配置并重启php：xdebug.remote_enable=1;远程调试开关xdebug.remote_host=localhost;远程调试客户端主机地址，也就是IDE所在主机的地址，往往就是localhostxdebug.remote_port=9000;远程调试端口配置好后，我们在浏览器中打开脚本，打开时需要发送GET/POST变量名XDEBUG_SESSION_START或者COOKIE变量名XDEBUG_SESSION，其值是Xdebug和调试客户端的通信会话id，往往是ide指定的一个特殊字符，如phpstorm指定为“PHPSTORM”，该值可以在xdebug.idekey配置中设定，默认为空字符串；浏览器附加的参数可以通过浏览器扩展自动完成（见下）；服务器收到请求后依据xdebug.remote_mode配置项的设定开始调试过程，该配置项如果是“req”那么脚本刚启动时Xdebug就向调试客户端（IDE）发起调试连接，这也是默认值，如果是“jit”那么仅在有错误出现时才发起连接，一旦和IDE的连接建立成功那么就采用DBGp协议进行调试交互。如果服务器是被多个开发者共享的，那么调试客户机会有多个，而xdebug.remote_host配置项只能设定一个，此时可以将xdebug.remote_connect_back设定为1，那将采用从http头中获取的ip来作为调试客户机的地址。Xdebug在发起调试连接时默认超时时间为200毫秒，该值在xdebug.remote_timeout配置项中设置，在本机调试该值足够了，如果是远程的网络主机那么需要加大该值以应对网络延迟。 浏览器插件辅助：如前文所述，触发方式产生分析、追踪文件和开启远程调试都需要在GET/POST 或COOKIE里面设置特定变量和值，那么我们能否让浏览器代劳呢，这是可以的，这里以开发者使用最多的火狐浏览器为列来说明：先安装辅助插件，打开地址：https://addons.mozilla.org/en-GB/firefox/addon/xdebug-helper-for-firefox/你将看到Xdebug Helper for Firefox ，点击Add to Firefox，按照提示操作即可安装完成后需要进行配置：按组合键“ctrl+shift+a”打开附加组件面板，找到Xdebug Helper，点击选项，分别输入IDE远程会话id、分析密钥、追踪密钥（对应配置中xdebug.idekey、xdebug.profiler_enable_trigger_value、xdebug.trace_enable_trigger_value），点击保存，此时新开网页的浏览器地址栏中将出现一个爬虫图标，可以选择四种状态：调试、分析、追踪、禁用，前三种种状态下浏览器打开连接时会附带额外的cookie参数，比如我们选择分析，那么刷新连接时将在cookie中添加XDEBUG_PROFILE变量，值为前文设定的密钥值，这将让Xdebug产生分析文件，函数追踪和远程调试同理。 【常用配置】全部设置及详细见：https://xdebug.org/docs/all_settings，本文只进行大概介绍xdebug.trace_output_dir函数调用跟踪数据文件的写入目录，默认为 /tmp，确保可写xdebug.trace_output_name追踪文件的文件名指引，默认为：trace.%c 比如：yunke.%s.%u 将输出带路径的脚步名及带微秒的时间，如下： yunke.C__root_test_index_php.1520473784_260486.xt xdebug.auto_trace开启函数调用追踪，布尔值，默认为0xdebug.collect_assignments布尔值，默认为0，是否在函数追踪中添加变量赋值xdebug.collect_includes布尔值，默认为1，是否将include(), include_once(), require() or require_once() 的文件写入追踪文件xdebug.collect_params整数，默认0，决定函数追踪的参数收集，0为不收集，1参数的类型和数量，2在1基础上加工具提示信息，3全变量内容（受到变量输出设置的影响），4全变量内容和变量名，5php序列化内容没有变量名xdebug.collect_return布尔值，默认0，是否写入函数调用的返回值到追踪文件xdebug.show_mem_delta整数，默认为0，非0值将显示函数调用的内存用量信息xdebug.trace_format整型，默认0，追踪文件的格式，0为人类可读格式（时间索引，内存用量等等）1机器易读格式 2人类可读格式以网页展现xdebug.trace_options整数，默认为0，如果设置为1，那么追踪文件采用追加方式，而不是覆盖xdebug.var_display_max_children整数，默认128，显示的数组子元素或对象属性的最大数量，不限制设定为-1，远程调试时不受影响xdebug.var_display_max_data整数，默认512，显示字符串的最大长度，不限设置为-1，不影响远程调试xdebug.var_display_max_depth整数，默认3，显示数组或对象属性时的最大嵌套深度，最大1023，可以用-1指代这个最大数xdebug.coverage_enable布尔，默认为1，是否开启代码覆盖分析，实测该设置项无效，开启和得到分析结果需用函数xdebug.gc_stats_enable布尔值，默认为0，是否开启垃圾回收统计分析xdebug.gc_stats_output_dir垃圾统计分析的写入目录，注意权限xdebug.gc_stats_output_name垃圾分析文件的文件名，和追踪分析的文件名规则一样xdebug.profiler_enable整数，默认为0，为1时将开启性能分析功能xdebug.profiler_aggregate整数，默认0，非0时将多个请求的分析数据写入一个文件中以进行跨请求分析xdebug.profiler_append整数，默认0，分析文件是否采用追加模式，文件名的设定对该项有影响xdebug.profiler_enable_trigger整数，默认为0，采用触发模式开启分析功能，开启它时需要关闭xdebug.profiler_enablexdebug.profiler_enable_trigger_value字符串。默认为“”，触发分析的密钥，配合xdebug.profiler_enable_trigger使用xdebug.profiler_output_dir字符串，默认为/tmp，分析文件输出目录xdebug.profiler_output_name分析文件名称，默认为cachegrind.out.%p，见xdebug.trace_output_namexdebug.extended_info整型，默认为1，是否强制php解析器执行extended_info模式xdebug.idekey字符串，默认: *complex*，调试会话id，经测试浏览器发送任意值均可开始调试，所以她并非密钥值，但有些调试客户端可以通过它来判断是否接受调试连接，所以最好统一xdebug.remote_addr_header默认为空字符串“”，用以指定哪个http头代表调试客户端地址，和xdebug.remote_connect_back 组合使用xdebug.remote_autostart布尔值，默认0，通常使用特定变量开始远程调试，如果该项被设置为1，那么总是开启xdebug.remote_connect_back布尔值，默认0，解决多人调试问题，忽略设定的固定ip，指示服务器依据请求地址链接xdebug.remote_cookie_expire_time整数。默认3600，远程调试cookie超期时间xdebug.remote_enable布尔值，默认0，是否启用远程调试xdebug.remote_host字符串，默认：localhost，远程调试客户端的地址xdebug.remote_log字符串，默认空，远程调试日志文件名xdebug.remote_mode字符串，远程调试默认，req脚本一启动就链接，jit当错误发生时链接xdebug.remote_port远程调试端主机端口，默认9000xdebug.remote_timeout整数，默认200，单位毫秒，等待调试链接的时间xdebug.default_enable布尔值，1或0，开启以xdebug的方式进行错误提示，默认开启xdebug.max_nesting_level整数，默认为：256，无限递归的保护机制，当递归调用达到该设定时程序被中断xdebug.max_stack_frames整数，默认值-1，设定错误提示时堆栈中有多少个帧被显示xdebug.scream布尔值，默认为0，是否禁用“@”，以便错误被强制显示 xdebug扩展开启后具备的函数：当扩展被加载后，php脚本中可以使用以下函数：（这里只列出部分，全部请见https://xdebug.org/docs/all_functions） string xdebug_call_class( [int $depth = 1] ) 显示调用类 string xdebug_call_file( [int $depth = 1] ) 显示调用文件 string xdebug_call_function( [int $depth = 1] ) 返回调用函数 int xdebug_call_line( [int $depth = 1] ) 返回调用行 void xdebug_disable() 禁用堆栈跟踪 void xdebug_enable() 开启堆栈跟踪 bool xdebug_is_enabled() 检查堆栈跟踪是否被开启 string xdebug_get_collected_errors( [int clean] ) 从错误集缓冲中返回所有错误信息 array xdebug_get_headers() 返回header() 函数设置的所有头信息 int xdebug_memory_usage() 返回内存使用量 int xdebug_peak_memory_usage() 返回到目前为止脚本使用过的最大内存用量 void xdebug_start_error_collection() 收集错误并禁止显示 void xdebug_stop_error_collection() 停止错误记录，并从缓冲中收集 float xdebug_time_index() 返回当前点的执行时间，单位秒 xdebug配置解释部分转载自 php调试工具Xdebug使用教程 三、配置PhpStorm打开PhpStorm 按 ctrl + alt + s打开设置界面，配置如下，Debug port 与在php.ini内配置的xdebug.remote_port对应；点击 apply 保存再点 ok 关闭 接下来配置服务器，在PhpStorm右上角下拉选择 “Edit Configurations” 如果没有服务器配置，需要新建一个；点击左上角的加号新建，新建类型我这里选择的是PHP Web Page ，也可以选择PHP application 再点击上图所示右侧的 server 配置服务器，Host根据实际情况填写，本地的话可以填localhost 下面点击行号的右边在PHP代码中打断点 首先点击PhpStorm右上角的电话图标，再点击虫子图标，这时会打开浏览器 可以看到已经自动在浏览器中打开了刚才配置的地址，但是这不是我们想要调试的页面，现在可以将红框内查询字符串前面的地址改成所要调试的地址 保留问号后的查询字符串，修改地址后按回车 PhpStorm就会自动显示断点位置的调试信息了 至此，PhpStorm + Xdebug 断点调试 配置完毕 四、浏览器插件调试除了上面所讲的利用XDEBUG_SESSION_START 地址栏query_string传值的方式，我们还可以利用COOKIE传递XDEBUG_SESSION，来使得PhpStorm能够检测到我们在浏览器发起的调试请求。XDEBUG_SESSION的值就是idekey的值，可以通过手动修改头信息的方式传递COOKIE，但是这样就比较麻烦，这时我们可以借助浏览器插件来帮我们设置COOKIE。 以Chrome为例，我们可以下载Chrome插件：Xdebug helper ，建议搭个梯子到Chrome官方插件商店下载。 添加成功之后鼠标右键点击浏览器右上角插件栏上的虫子，进入“选项”将IDEKEY设置成PHPSTORM并保存，就可以愉快的开始调试了 点击浏览器右上角的灰色虫子，选择debug选项，虫子变为绿色就开启了； 接下来还要开启PhpStorm监听，点击PhpStorm右上角的电话按钮，变成如下样式就代表开启了监听。与之前不同的是，使用浏览器插件调试时不需要点击PhpStorm右上角的虫子获取ID。 打断点后运行，就可以看到调试信息了","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://jiangwennn.github.io/tags/PHP/"}],"author":"Jiangwennn"},{"title":"LAMP环境搭建","slug":"lamp-env-build","date":"2019-01-25T05:29:59.000Z","updated":"2022-06-26T12:42:23.382Z","comments":true,"path":"/post/lamp-env-build.html","link":"","permalink":"http://jiangwennn.github.io/post/lamp-env-build.html","excerpt":"","text":"LAMP环境搭建是PHP程序员必须掌握的一项基本技能，但是对于初学者来说，操作步骤比较繁琐。本文是作者个人对LAMP环境搭建的整个流程的理解，在此学习分享，希望对学习PHP的同学有所帮助，欢迎指正错误哦~ ####一、 Linux安装（CentOS） 如果是本地测试环境，则需要安装虚拟机软件，这里使用的是VirtualBox，下载好后根据自己需要安装在相应的位置就好了。 CentOS的ISO文件下载好以后用虚拟机打开安装。 相关文章：Windows下利用VirtualBox安装CentOS虚拟机 二、安装环境准备 更新yum源： yum -y update 安装wget 和 vim： yum -y install wget vimwget用于下载文件，本教程下载的都是tar.gz格式的压缩包；vim为编辑器 安装编译环境：yum -y install gcc gcc-c++ libxml2-devel libtool expat-devel automake autoconf make这里安装了c和c++的编译环境以及可能需要用到的库 (重要)本教程使用root用户执行所有指令，如果使用其他用户，某些步骤可能需要添加sudo命令才能执行；所有文件下载均在/root目录下，请注意每一步骤执行时所在的目录。 三、Apache 安装 apr 和 apr-util 下载安装apr官网可以下载到apr和apr-util的源码本教程下载的是apr-1.6.5.tar.gz和apr-util-1.6.1.tar.gz进入root目录：cd /root下载使用wget：wget http://mirrors.hust.edu.cn/apache/apr/apr-1.6.5.tar.gzwget http://mirrors.hust.edu.cn/apache/apr/apr-util-1.6.1.tar.gz 下载完成后开始解压并编译安装apr-1.6.5 tar -zvxf apr-1.6.5.tar.gz cd apr-1.6.5 ./configure --prefix=/usr/local/apr make &amp;&amp; make install 再安装apr-util-1.6.1 cd /root tar -zvxf apr-util-1.6.1.tar.gz cd apr-util-1.6.1 ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr make &amp;&amp; make install 除了编译安装方式，也可以在编译httpd时，将apr 和apr-util解压到httpd源码目录下的srclib目录，分别命名为apr和apr-util；执行httpd./configure时，将 --with-apr=/usr/local/apr 和 --with-apr-util=/usr/local/apr-util两个配置项改为 --with-apr-included执行 pcre 下载安装进入root目录：cd /rootpcre可以从Index of pcre下载wget https://ftp.pcre.org/pub/pcre/pcre-8.42.tar.gz下载完成后解压编译安装 tar -zvxf pcre-8.42.tar.gz cd pcre-8.42 ./configure make &amp;&amp; make install zlib 下载安装进入root目录：cd /root从zlib官网找到下载链接wget http://www.zlib.net/zlib-1.2.11.tar.gz下载完成后解压安装 tar -zxvf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure make &amp;&amp; make install openssl 下载安装进入root目录：cd /rootIndex of openssl上可以下载openssl源码包wget http://distfiles.macports.org/openssl/openssl-1.0.2q.tar.gz下载完成后解压安装 tar -zxvf openssl-1.0.2q.tar.gz cd openssl-1.0.2q ./config shared zlib make &amp;&amp; make install httpd 下载安装进入root目录：cd /rootApache官网上可以下载到最新版本的源码下载：wget http://mirror.bit.edu.cn/apache/httpd/httpd-2.4.38.tar.gz解压：tar -zvxf httpd-2.4.38.tar.gz解压完成进入httpd-2.4.38目录：cd httpd-2.4.38配置编译安装选项：./configure --prefix=/usr/local/apache --with-zlib=/usr/local/zlib --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util --with-ssl=/usr/local/ssl --enable-so --enable-dav --enable-ssl --enable-rewrite --enable-modules=most --enable-maintainer-mode编译安装：make &amp;&amp; make install 至此apache的安装就完成了执行命令启动apache /usr/local/apache/bin/apachectl start启动的时候可能会报错: httpd: Syntax error on line 134 of /usr/local/apache/conf/httpd.conf: Cannot load modules/mod_ssl.so into server: libssl.so.1.0.0: cannot open shared object file: No such file or directory 解决方法,在/etc/ld.so.conf文件中写入openssl库文件的搜索路径:echo &quot;/usr/local/lib64&quot; &gt;&gt; /etc/ld.so.conf再使用ldconfig -v命令查看动态链接生效结果 如果动态链接之后依然不生效，检查一下/usr/local/lib64文件夹是否存在，某些系统可能是/usr/local/lib；检查的时候顺便进lib目录里查看libssl.so.1.0.0和libcrypto.so.1.0.0 是否存在，如果不存在的话需要到openssl源码目录下复制过来； cd /root/openssl-1.0.2q cp libssl.so.1.0.0 /usr/local/lib64 cp libcrypto.so.1.0.0 /usr/local/lib64 ldconfig -v 再次执行命令启动Apache，如果再出现以下错误，是httpd.conf配置的原因，暂时先不管 AH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using localhost.localdomain. Set the &#39;ServerName&#39; directive globally to suppress this message 在浏览器输入服务器IP地址访问，显示如下则安装成功 若服务器无响应，有可能是防火墙80端口未开放；对于云服务器也有可能是因为没有配置安全组规则。开放80端口：firewall-cmd --zone=public --add-port=80/tcp --permanent重启防火墙：systemctl restart firewalld.service ####三、PHP安装下载php源码，可以从php官方 https://secure.php.net/releases/找到各版本下载链接 进入root目录：cd /root开始下载：wget https://www.php.net/distributions/php-7.2.9.tar.gz 解压：tar -zxvf php-7.2.9.tar.gz进入目录：cd php-7.2.9配置安装目录和模块加载等信息：./configure --prefix=/usr/local/php --with-apxs2=/usr/local/apache/bin/apxs --with-config-file-path=/usr/local/php --with-mysql=mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --enable-mbstring php7已经不再支持使用mysql扩展，因此配置时会出现如下提示，可忽略： configure: WARNING: unrecognized options: --with-mysql 接下来编译安装：make &amp;&amp; make install 编译完成后使用vim新建一个测试文件：vim phpinfo.php按a键进入编辑模式，输入测试代码： &lt;?php echo phpinfo();?&gt; 再按下ESC回到命令模式，输入:wq命令后按enter键保存并退出输入/usr/local/php/bin/php phpinfo.php命令执行测试文件返回phpinfo结果如下则php安装成功 ####四、MySQL安装 #####1.检测是否安装MySQL Linux平台上推荐使用RPM包来安装MySQL安装前，我们可以检测系统是否自带安装 MySQL:rpm -qa | grep mysql如果你系统有安装，那可以选择进行卸载:普通删除模式 ：rpm -e mysql 如果使用普通删除命令删除时，提示有依赖的其它文件，则用强力删除模式：rpm -e --nodeps mysql 可以对其进行强力删除 #####2.安装MySQL 使用wget下载rpm包 wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm再依次执行以下命令用yum进行安装 rpm -ivh mysql-community-release-el7-5.noarch.rpm yum -y update yum -y install mysql-server 安装完成后进行权限设置：chown mysql:mysql -R /var/lib/mysql 启动MySQL:systemctl start mysqld查看MySQL状态：systemctl status mysqld 如果我们是第一次启动 mysql 服务，mysql 服务器首先会进行初始化的配置。 #####3.验证MySQL安装 使用 mysqladmin 工具来获取服务器状态：mysqladmin --version显示结果基于你的系统信息： mysqladmin Ver 8.42 Distrib 5.6.43, for Linux on x86_64 使用MySQL客户端命令连接至MySQL服务器：mysql出现如下界面则连接成功： Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 2 Server version: 5.6.43 MySQL Community Server (GPL) Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement. mysql&gt; 使用exit;命令断开连接 #####4.修改密码 MySQL安装成功后，默认root密码为空，需要进行设置使用命令修改root密码：mysqladmin -u root password &quot;12345678&quot;;可能会提示如下安全风险，可忽略： Warning: Using a password on the command line interface can be insecure. 输入命令登录MySQL mysql -uroot -p，使用该命令后会提示输入密码，输入即可 登陆成功后可以使用MySQL命令对MySQL数据库进行操作了。 #####5.远程管理MySQL 如果需要远程管理数据库，则需要用户有远程访问权限，即user表host字段的值为% 可以使用下面的命令新建一个具有全部权限的用户 remote_admin： GRANT ALL PRIVILEGES ON *.* TO &#39;remote_admin&#39; IDENTIFIED BY &#39;12345678&#39; WITH GRANT OPTION; 如果还不能远程连接，有可能是防火墙3306端口未开放 开放3306端口：firewall-cmd --zone=public --add-port=3306/tcp --permanent重启防火墙：systemctl restart firewalld.service ####五、配置Apache和PHP 使用vim打开Apache的配置文件：vim /usr/local/apache/conf/httpd.conf #####1.添加PHP支持： 在文件中添加一行；如果PHP版本为5.X，则需要加载PHP5的模块 LoadModule php7_module modules/libphp7.so 在DirectoryIndex 后添加 index.php DirectoryIndex index.html index.php 在&lt;IfModule mime_module&gt;下添加两行 AddType application/x-httpd-php .php .phtml AddType application/x-httpd-php-source .phps #####2.修改ServerName 去掉ServerName前的#号，将其改成如下形式： ServerName localhost #####3.开启Apache支持伪静态 将rewrite模块加载前的#号去掉 LoadModule rewrite_module modules/mod_rewrite.so 将&lt;Directory &quot;/usr/local/apache/htdocs&quot;&gt;标签下的 AllowOverride None修改为 AllowOverride all #####4.不显示目录结构 将&lt;Directory &quot;/usr/local/apache/htdocs&quot;&gt;标签下的 Options Indexes FollowSymLinks修改为 Options FollowSymLinks #####5.修改php.ini 我们在安装PHP的时候设置了配置文件的路径--with-config-file-path=/usr/local/php但是目前/usr/local/php/路径下并没有php.ini文件，而在解压目录/root/php-7.2.9下有两个php配置文件分别是php.ini-development和php.ini-production这两个文件是开发环境和生产环境的默认配置，这里我们使用开发环境使用cp命令复制： cp /root/php-7.2.9/php.ini-development /usr/local/php/php.ini #####6.验证服务器能否解析PHP首先重启Apache：/usr/local/apache/bin/apachectl restart没有返回任何结果，则表明重启成功 使用管道符&gt;新建一个测试文件echo &#39;&lt;?php phpinfo();&#39; &gt; /usr/local/apache/htdocs/phpinfo.php 打开浏览器输入地址http://IP地址/phpinfo.php显示phpinfo信息则配置成功","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://jiangwennn.github.io/tags/PHP/"},{"name":"Linux","slug":"Linux","permalink":"http://jiangwennn.github.io/tags/Linux/"}]}],"categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://jiangwennn.github.io/tags/Windows/"},{"name":"Scoop","slug":"Scoop","permalink":"http://jiangwennn.github.io/tags/Scoop/"},{"name":"MySQL","slug":"MySQL","permalink":"http://jiangwennn.github.io/tags/MySQL/"},{"name":"PHP","slug":"PHP","permalink":"http://jiangwennn.github.io/tags/PHP/"},{"name":"Linux","slug":"Linux","permalink":"http://jiangwennn.github.io/tags/Linux/"}]}